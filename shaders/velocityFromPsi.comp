#version 450
layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(set = 0, binding = 3) readonly buffer StreamFunctionBuffer {
    float streamFuncScalars[];
};
layout(set = 0, binding = 5) writeonly buffer TempVectorBuffer {
    vec2 tempVec2[];
};

layout(push_constant) uniform PushConstants {
    uvec2 gridDim;
    float deltaTime;
    float density;
    float viscosity;
    int numPressureIterations;
    int numOverallIterations;
    float omegaSOR;
    float lidVelocity;
    float h;
} pc;

uint getIndex(uvec2 coord) {
    return coord.y * pc.gridDim.x + coord.x;
}

void main() {
    uvec2 id = gl_GlobalInvocationID.xy;
    uint current_idx = getIndex(id);
    vec2 new_vel;

    // Boundary conditions for velocity
    if (id.y == pc.gridDim.y - 1) { // Top boundary (lid)
        new_vel = vec2(pc.lidVelocity, 0.0);
    } else if (id.y == 0 || id.x == 0 || id.x == pc.gridDim.x - 1) { // Other walls
        new_vel = vec2(0.0, 0.0);
    } else {
        // Interior points: calculate derivatives of ψ
        // Since ψ=0 on boundaries, one-sided differences are implicitly handled if neighbors are sampled from StreamFunctionBuffer
        // where boundary psi values are correctly set to 0.
        float psi_xp = streamFuncScalars[getIndex(id + uvec2(1, 0))];
        float psi_xn = streamFuncScalars[getIndex(id - uvec2(1, 0))];
        float psi_yp = streamFuncScalars[getIndex(id + uvec2(0, 1))];
        float psi_yn = streamFuncScalars[getIndex(id - uvec2(0, 1))];

        float dpsi_dx = (psi_xp - psi_xn) / (2.0 * pc.h);
        float dpsi_dy = (psi_yp - psi_yn) / (2.0 * pc.h);

        new_vel.x = dpsi_dy;
        new_vel.y = -dpsi_dx;
    }

    tempVec2[current_idx] = new_vel;
}
