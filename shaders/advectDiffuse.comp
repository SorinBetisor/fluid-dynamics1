#version 450
layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(set = 0, binding = 0) readonly buffer VelocityBuffer {
    vec2 velocities[];
};
layout(set = 0, binding = 1) readonly buffer VorticityBuffer {
    float vorticity[];
};
layout(set = 0, binding = 4) writeonly buffer TempScalarBuffer {
    float tempScalar[];
};

layout(push_constant) uniform PushConstants {
    uvec2 gridDim; // Grid dimensions (width, height)
    float deltaTime; // Time step Δt
    float density; // Fluid density ρ (not directly used if viscosity is kinematic)
    float viscosity; // Kinematic viscosity ν
    int numPressureIterations; // Iterations for Poisson solver (max_it for ψ)
    int numOverallIterations; // Total simulation steps (unused in this shader)
    float omegaSOR; // Relaxation factor for SOR in Poisson solver (ω_SOR)
    float lidVelocity; // Velocity of the top lid (U0)
    float h; // Cell size (Δx = Δy = h)
} pc;

uint getIndex(uvec2 coord) {
    return coord.y * pc.gridDim.x + coord.x;
}

// Helper to safely sample vorticity with clamping (replicating edge values)
float sampleWSafe(uvec2 coord) {
    uvec2 clampedCoord = clamp(coord, uvec2(0, 0), pc.gridDim - uvec2(1, 1));
    return vorticity[getIndex(clampedCoord)];
}

void main() {
    uvec2 id = gl_GlobalInvocationID.xy;
    uint current_idx = getIndex(id);

    // For advection/diffusion, boundary cells' vorticity is often set by `vorticity.comp`'s specific boundary formulas.
    // The `euler` function in C processes all cells. If boundary conditions for vorticity are handled by `vorticity.comp`
    // this step might only need to operate on interior cells, or use the boundary vorticities as is.
    // Here, we process all cells, using clamped sampling for neighbors.

    float w_old = vorticity[current_idx];
    vec2 vel = velocities[current_idx];

    // Central differences for derivatives of vorticity
    float w_xp = sampleWSafe(id + uvec2(1, 0));
    float w_xn = sampleWSafe(id - uvec2(1, 0));
    float w_yp = sampleWSafe(id + uvec2(0, 1));
    float w_yn = sampleWSafe(id - uvec2(0, 1));

    float dw_dx = (w_xp - w_xn) / (2.0 * pc.h);
    float dw_dy = (w_yp - w_yn) / (2.0 * pc.h);

    float d2w_dx2 = (w_xp - 2.0 * w_old + w_xn) / (pc.h * pc.h);
    float d2w_dy2 = (w_yp - 2.0 * w_old + w_yn) / (pc.h * pc.h);

    float advection_term = -vel.x * dw_dx - vel.y * dw_dy;
    float diffusion_term = pc.viscosity * (d2w_dx2 + d2w_dy2);

    float w_new = w_old + pc.deltaTime * (advection_term + diffusion_term);

    // If current cell IS a boundary, its new value might be overwritten by specific BCs later.
    // The C code's `euler` updates w, then `main` loop re-calculates boundary `w` from velocities.
    // This shader computes an intermediate w* for all points.

    tempScalar[current_idx] = w_new;
}
