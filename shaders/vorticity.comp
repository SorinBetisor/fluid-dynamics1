#version 450
layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(set = 0, binding = 0) readonly buffer VelocityBuffer {
    vec2 velocities[];
};
// Binding 1 (VorticityBuffer) is not strictly needed here if we compute fresh vorticity
layout(set = 0, binding = 3) readonly buffer StreamFunctionBuffer {
    float streamFuncScalars[];
};
layout(set = 0, binding = 4) writeonly buffer TempScalarBuffer {
    float tempScalar[];
};

layout(push_constant) uniform PushConstants {
    uvec2 gridDim;
    float deltaTime;
    float density;
    float viscosity;
    int numPressureIterations;
    int numOverallIterations;
    float omegaSOR;
    float lidVelocity;
    float h;
} pc;

uint getIndex(uvec2 coord) {
    return coord.y * pc.gridDim.x + coord.x;
}

void main() {
    uvec2 id = gl_GlobalInvocationID.xy;
    uint out_idx = getIndex(id);

    float u_curr = velocities[getIndex(id)].x;
    float v_curr = velocities[getIndex(id)].y;

    float u_up, u_down, v_left, v_right;
    float du_dy, dv_dx;

    // Handle boundaries for derivatives
    // Top boundary (y = gridDim.y - 1)
    if (id.y == pc.gridDim.y - 1) {
        u_up = pc.lidVelocity; // Lid velocity
        u_down = velocities[getIndex(uvec2(id.x, id.y - 1))].x;
        du_dy = (u_up - u_down) / pc.h; // One-sided difference (top physical boundary)
    }
    // Bottom boundary (y = 0)
    else if (id.y == 0) {
        u_up = velocities[getIndex(uvec2(id.x, id.y + 1))].x;
        u_down = 0.0; // Wall velocity
        du_dy = (u_up - u_down) / pc.h; // One-sided difference (bottom physical boundary)
    }
    // Interior y
    else {
        u_up = velocities[getIndex(uvec2(id.x, id.y + 1))].x;
        u_down = velocities[getIndex(uvec2(id.x, id.y - 1))].x;
        du_dy = (u_up - u_down) / (2.0 * pc.h); // Central difference
    }

    // Right boundary (x = gridDim.x - 1)
    if (id.x == pc.gridDim.x - 1) {
        v_right = 0.0; // Wall velocity
        v_left = velocities[getIndex(uvec2(id.x - 1, id.y))].y;
        dv_dx = (v_right - v_left) / pc.h; // One-sided difference
    }
    // Left boundary (x = 0)
    else if (id.x == 0) {
        v_right = velocities[getIndex(uvec2(id.x + 1, id.y))].y;
        v_left = 0.0; // Wall velocity
        dv_dx = (v_right - v_left) / pc.h; // One-sided difference
    }
    // Interior x
    else {
        v_right = velocities[getIndex(uvec2(id.x + 1, id.y))].y;
        v_left = velocities[getIndex(uvec2(id.x - 1, id.y))].y;
        dv_dx = (v_right - v_left) / (2.0 * pc.h); // Central difference
    }

    // Specific vorticity boundary conditions from common CFD practice for lid-driven cavity (alternative to above general derivatives):
    // ω_wall = 2 * (u_neighbor_normal - u_wall_tangential) / h_normal
    // Bottom wall (y=0): ω = -2 * u(i,1) / h  (since u_wall = 0, v_wall = 0 means dv/dx approx 0 at wall)
    // Top wall (y=Ny-1): ω = 2 * (pc.lidVelocity - u(i,Ny-2)) / h
    // Left wall (x=0): ω = 2 * v(1,j) / h
    // Right wall (x=Nx-1): ω = -2 * v(Nx-2,j) / h
    // For simplicity here, the general derivative form is kept, but for high accuracy, specific wall vorticity formulas are better.
    // The C code calculates dvdx and dudy matrices first, then combines. The approach above is cell-local.

    tempScalar[out_idx] = dv_dx - du_dy;
}
