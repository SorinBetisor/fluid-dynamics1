#version 450
layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(set = 0, binding = 0) readonly buffer VelocityBuffer {
    vec2 velocities[];
};
// Binding 1 (VorticityBuffer) is not strictly needed here if we compute fresh vorticity
layout(set = 0, binding = 3) readonly buffer StreamFunctionBuffer {
    float streamFuncScalars[];
};
layout(set = 0, binding = 4) writeonly buffer TempScalarBuffer {
    float tempScalar[];
};

layout(push_constant) uniform PushConstants {
    uvec2 gridDim;
    float deltaTime;
    float density;
    float viscosity;
    int numPressureIterations;
    int numOverallIterations;
    float omegaSOR;
    float lidVelocity;
    float h;
} pc;

void main() {
    ivec2 ij = ivec2(gl_GlobalInvocationID.xy);
    uint W = pc.gridDim.x;
    uint H = pc.gridDim.y;
    uint idx = ij.y * W + ij.x;
    // tempScalar[idx] = 1;
    if (ij.x >= W || ij.y >= H) return; // Safety bounds check

    float h_sq = pc.h * pc.h;

    // --- Boundary Conditions for Vorticity ---
    // Using Thom's formula or similar (first-order accurate)
    // Assumes stream function (ψ) is 0 on stationary boundaries.
    if (ij.y == 0 && ij.x > 0 && ij.x < W - 1) { // Bottom wall (not corners)
        // ω_wall = -2 * ψ_neighbor_in_fluid / h²
        tempScalar[idx] = -2.0 * streamFuncScalars[idx + W] / h_sq;
    } else if (ij.y == int(H) - 1 && ij.x > 0 && ij.x < W - 1) { // Top lid (not corners)
        // ω_lid = -2 * ψ_neighbor_in_fluid / h² - 2 * U_lid / h
        tempScalar[idx] = -2.0 * streamFuncScalars[idx - W] / h_sq - 2.0 * pc.lidVelocity / pc.h;
    } else if (ij.x == 0 && ij.y > 0 && ij.y < H - 1) { // Left wall (not corners)
        tempScalar[idx] = -2.0 * streamFuncScalars[idx + 1] / h_sq;
    } else if (ij.x == int(W) - 1 && ij.y > 0 && ij.y < H - 1) { // Right wall (not corners)
        tempScalar[idx] = -2.0 * streamFuncScalars[idx - 1] / h_sq;
    }
    // Handle Corners (can average from adjacent walls or use specific formulas)
    // Simplification: Apply wall formulas, let adjacencies define corners.
    // Example: Bottom-left corner (ij.x == 0 && ij.y == 0)
    else if (ij.x == 0 && ij.y == 0) { // Bottom-left corner
        tempScalar[idx] = -2.0 * (streamFuncScalars[idx + W] + streamFuncScalars[idx + 1]) / h_sq; // Average-ish
    } else if (ij.x == W - 1 && ij.y == 0) { // Bottom-right
        tempScalar[idx] = -2.0 * (streamFuncScalars[idx + W] + streamFuncScalars[idx - 1]) / h_sq;
    } else if (ij.x == 0 && ij.y == H - 1) { // Top-left
        tempScalar[idx] = -2.0 * (streamFuncScalars[idx - W] + streamFuncScalars[idx + 1]) / h_sq
                - 2.0 * pc.lidVelocity / pc.h; // Lid influence
    } else if (ij.x == W - 1 && ij.y == H - 1) { // Top-right
        tempScalar[idx] = -2.0 * (streamFuncScalars[idx - W] + streamFuncScalars[idx - 1]) / h_sq
                - 2.0 * pc.lidVelocity / pc.h; // Lid influence
    } else { // --- Interior points: ω = ∂v/∂x - ∂u/∂y ---
        uint ip = idx + 1;
        uint im = idx - 1;
        uint jp = idx + W;
        uint jm = idx - W;

        // ∂v/∂x
        float dvdx = (velocities[ip].y - velocities[im].y) * (0.5 / pc.h);
        // ∂u/∂y
        float dudy = (velocities[jp].x - velocities[jm].x) * (0.5 / pc.h);

        tempScalar[idx] = dvdx - dudy;
    }
}
