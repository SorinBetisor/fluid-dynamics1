#version 450
layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(set = 0, binding = 0) readonly buffer VelocityBuffer {
    vec2 velocities[];
};
layout(set = 0, binding = 2) readonly buffer PressureBuffer {
    float pressures[];
};
layout(set = 0, binding = 4) writeonly buffer TempScalarBuffer {
    float tempScalar[];
};

layout(push_constant) uniform PushConstants {
    uvec2 gridDim; // Grid dimensions (width, height)
    float deltaTime; // Time step Δt
    float density; // Fluid density ρ (not directly used if viscosity is kinematic)
    float viscosity; // Kinematic viscosity ν
    int numPressureIterations; // Iterations for Poisson solver (max_it for ψ)
    int numOverallIterations; // Total simulation steps (unused in this shader)
    float omegaSOR; // Relaxation factor for SOR in Poisson solver (ω_SOR)
    float lidVelocity; // Velocity of the top lid (U0)
    float h; // Cell size (Δx = Δy = h)
} pc;

uint getIndex(uvec2 coord) {
    return coord.y * pc.gridDim.x + coord.x;
}

// Helper to safely sample PressureBuffer with Neumann boundary condition (dP/dn=0 -> P_boundary = P_interior_neighbor)
float samplePressureNeumann(uvec2 coord, uvec2 id_orig) {
    ivec2 c = ivec2(coord);
    ivec2 gdim = ivec2(pc.gridDim);
    if (c.x < 0) c.x = 0; // P_(-1,j) = P_(0,j) effectively by clamping, or P_(-1,j) = P_(1,j) for central difference from P_0
    else if (c.x >= gdim.x) c.x = gdim.x - 1;
    if (c.y < 0) c.y = 0;
    else if (c.y >= gdim.y) c.y = gdim.y - 1;

    // More explicit Neumann: if coord is outside, take value from one step inside boundary
    if (coord.x >= pc.gridDim.x) return pressures[getIndex(uvec2(pc.gridDim.x - 2, coord.y))]; // approx P(N) = P(N-1)
    if (coord.x == uvec2(-1).x) return pressures[getIndex(uvec2(1, coord.y))]; // approx P(-1)=P(0)
    if (coord.y >= pc.gridDim.y) return pressures[getIndex(uvec2(coord.x, pc.gridDim.y - 2))];
    if (coord.y == uvec2(-1).y) return pressures[getIndex(uvec2(coord.x, 1))];

    // Simpler: sample P at id, and if id is boundary, its neighbors are handled by this logic:
    // For a boundary cell at id_orig: P_neighbor_outside = P_id_orig (for dP/dn=0 with one-sided diff)
    // Or P_neighbor_outside = P_neighbor_inside (for central diff at boundary)
    if (id_orig.x == 0 && coord.x < id_orig.x) return pressures[getIndex(uvec2(id_orig.x + 1, id_orig.y))]; // P_xn = P_xp
    if (id_orig.x == pc.gridDim.x - 1 && coord.x > id_orig.x) return pressures[getIndex(uvec2(id_orig.x - 1, id_orig.y))]; // P_xp = P_xn
    if (id_orig.y == 0 && coord.y < id_orig.y) return pressures[getIndex(uvec2(id_orig.x, id_orig.y + 1))]; // P_yn = P_yp
    if (id_orig.y == pc.gridDim.y - 1 && coord.y > id_orig.y) return pressures[getIndex(uvec2(id_orig.x, id_orig.y - 1))]; // P_yp = P_yn

    // Default: clamp to edge (this is simpler for implementation)
    uvec2 clampedCoord = clamp(coord, uvec2(0, 0), pc.gridDim - uvec2(1, 1));
    return pressures[getIndex(clampedCoord)];
}

void main() {
    uvec2 id = gl_GlobalInvocationID.xy;
    uint current_idx = getIndex(id);

    // Compute velocity derivatives for the source term F_p
    // Using central differences, carefully at boundaries for velocity
    vec2 vel_curr = velocities[current_idx];

    vec2 vel_xp = velocities[getIndex(clamp(id + uvec2(1, 0), uvec2(0), pc.gridDim - uvec2(1)))];
    vec2 vel_xn = velocities[getIndex(clamp(id - uvec2(1, 0), uvec2(0), pc.gridDim - uvec2(1)))];
    vec2 vel_yp = velocities[getIndex(clamp(id + uvec2(0, 1), uvec2(0), pc.gridDim - uvec2(1)))];
    vec2 vel_yn = velocities[getIndex(clamp(id - uvec2(0, 1), uvec2(0), pc.gridDim - uvec2(1)))];

    // Override for physical boundaries if needed
    if (id.x == 0) vel_xn = vec2(0.0); // Left wall u=0, v=0
    if (id.x == pc.gridDim.x - 1) vel_xp = vec2(0.0); // Right wall u=0, v=0
    if (id.y == 0) vel_yn = vec2(0.0); // Bottom wall u=0, v=0
    if (id.y == pc.gridDim.y - 1) vel_yp = vec2(pc.lidVelocity, 0.0); // Top wall u=U0, v=0

    float du_dx = (vel_xp.x - vel_xn.x) / (2.0 * pc.h);
    float du_dy = (vel_yp.x - vel_yn.x) / (2.0 * pc.h);
    float dv_dx = (vel_xp.y - vel_xn.y) / (2.0 * pc.h);
    float dv_dy = (vel_yp.y - vel_yn.y) / (2.0 * pc.h);

    // Special handling for cells adjacent to boundaries if using central differences
    if (id.x == 0) { // Left boundary
        du_dx = (velocities[getIndex(id + uvec2(1, 0))].x - 0.0) / pc.h; // Forward
        dv_dx = (velocities[getIndex(id + uvec2(1, 0))].y - 0.0) / pc.h; // Forward
    }
    if (id.x == pc.gridDim.x - 1) { // Right boundary
        du_dx = (0.0 - velocities[getIndex(id - uvec2(1, 0))].x) / pc.h; // Backward
        dv_dx = (0.0 - velocities[getIndex(id - uvec2(1, 0))].y) / pc.h; // Backward
    }
    if (id.y == 0) { // Bottom boundary
        du_dy = (velocities[getIndex(id + uvec2(0, 1))].x - 0.0) / pc.h; // Forward
        dv_dy = (velocities[getIndex(id + uvec2(0, 1))].y - 0.0) / pc.h; // Forward
    }
    if (id.y == pc.gridDim.y - 1) { // Top boundary
        du_dy = (pc.lidVelocity - velocities[getIndex(id - uvec2(0, 1))].x) / pc.h; // Backward for u
        dv_dy = (0.0 - velocities[getIndex(id - uvec2(0, 1))].y) / pc.h; // Backward for v
    }

    float f_pressure = du_dx * du_dx + dv_dy * dv_dy + 2.0 * du_dy * dv_dx;
    float source_term_pressure = -pc.density * f_pressure; // For ∇²P = source_term_pressure
    // C code is p = fft_poisson(-f,dx), so ∇²P = -f.
    // So source term is -f_pressure. pc.density is often 1.
    // Let's assume pc.density = 1 for this example matching C.
    // So source_term_for_SOR_formula = -f_pressure.

    // SOR iteration for Pressure
    float P_old = pressures[current_idx];

    float P_xp = samplePressureNeumann(id + uvec2(1, 0), id);
    float P_xn = samplePressureNeumann(id - uvec2(1, 0), id);
    float P_yp = samplePressureNeumann(id + uvec2(0, 1), id);
    float P_yn = samplePressureNeumann(id - uvec2(0, 1), id);

    float term_P_neighbors = P_xp + P_xn + P_yp + P_yn;
    // Formula uses: 0.25 * (neighbor_sum - h*h * source_for_nabla_sq_equals_source)
    // If ∇²P = -f_pressure, then source_for_nabla_sq_equals_source is -f_pressure
    float P_GS = 0.25 * (term_P_neighbors - pc.h * pc.h * (-f_pressure));
    // = 0.25 * (term_P_neighbors + pc.h * pc.h * f_pressure); (Using pc.density=1)

    float P_new = pc.omegaSOR * P_GS + (1.0 - pc.omegaSOR) * P_old;

    // Pressure is often relative; fix one point if needed (e.g. P at (0,0) = 0) by host or another shader.
    // if (id.x == 0 && id.y == 0) P_new = 0.0; // Example of fixing a pressure point

    tempScalar[current_idx] = P_new;
}
