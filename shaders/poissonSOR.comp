#version 450
layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(set = 0, binding = 1) readonly buffer VorticityBuffer {
    float vorticity[];
};
layout(set = 0, binding = 3) readonly buffer StreamFunctionBuffer {
    float streamFuncScalars[];
};
layout(set = 0, binding = 4) writeonly buffer TempScalarBuffer {
    float tempScalar[];
};

layout(push_constant) uniform PushConstants {
    uvec2 gridDim; // Grid dimensions (width, height)
    float deltaTime; // Time step Δt
    float density; // Fluid density ρ (not directly used if viscosity is kinematic)
    float viscosity; // Kinematic viscosity ν
    int numPressureIterations; // Iterations for Poisson solver (max_it for ψ)
    int numOverallIterations; // Total simulation steps (unused in this shader)
    float omegaSOR; // Relaxation factor for SOR in Poisson solver (ω_SOR)
    float lidVelocity; // Velocity of the top lid (U0)
    float h; // Cell size (Δx = Δy = h)
} pc;

uint getIndex(uvec2 coord) {
    return coord.y * pc.gridDim.x + coord.x;
}

void main() {
    uvec2 id = gl_GlobalInvocationID.xy;
    uint current_idx = getIndex(id);
    float psi_new;

    // Boundary condition: ψ = 0 on all walls
    if (id.x == 0 || id.x == pc.gridDim.x - 1 || id.y == 0 || id.y == pc.gridDim.y - 1) {
        psi_new = 0.0;
    } else {
        // Interior points: SOR iteration
        float psi_old = streamFuncScalars[current_idx];

        float psi_xp = streamFuncScalars[getIndex(id + uvec2(1, 0))];
        float psi_xn = streamFuncScalars[getIndex(id - uvec2(1, 0))];
        float psi_yp = streamFuncScalars[getIndex(id + uvec2(0, 1))];
        float psi_yn = streamFuncScalars[getIndex(id - uvec2(0, 1))];

        float source_term_omega = vorticity[current_idx]; // This is ω from VorticityBuffer. For ∇²ψ = -ω, use -source_term_omega.
        // C code `invsig(w)` then uses `w` as `f`. So `f` in C is `-original_omega`.
        // Formula: (A - B*f)/C. If f = -ω, then (A + B*ω)/C.
        // The C code `poisson_SOR` takes `f`. `main` passes `w` (which was inverted). So `f` is `-original_omega`.
        // The formula uses `- dx*dx*dy*dy*f.M[i][j]`. So `- pc.h*pc.h*pc.h*pc.h * (-source_term_omega)` if VorticityBuffer contains original omega.
        // Or `pc.h*pc.h*pc.h*pc.h * source_term_omega` if VorticityBuffer contains `w_inverted`.
        // Assuming VorticityBuffer contains original ω.
        // Then `f.M[i][j]` in C context corresponds to `-source_term_omega`.
        // `psi_new_GS = 0.25 * (neighbor_sum - h*h * f_val)`
        // `psi_new_GS = 0.25 * (psi_xp + psi_xn + psi_yp + psi_yn - pc.h*pc.h * (-source_term_omega) )`
        // `psi_new_GS = 0.25 * (psi_xp + psi_xn + psi_yp + psi_yn + pc.h*pc.h * source_term_omega )`

        float term_neighbors = psi_xp + psi_xn + psi_yp + psi_yn;
        float psi_GS = 0.25 * (term_neighbors + pc.h * pc.h * source_term_omega); // Corresponds to ∇²ψ = -ω

        psi_new = pc.omegaSOR * psi_GS + (1.0 - pc.omegaSOR) * psi_old;
    }

    tempScalar[current_idx] = psi_new;
}
